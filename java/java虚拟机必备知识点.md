#### JVM内存分析

**分为哪些部分？**
>
* Method Area（线程共享）
* Heap（线程共享）
* VM Stack （线程私有）
* Native Method Stack（线程私有）
* Program Counter Register（线程私有）
>

**Method Area**

* 是什么？

>
保持已经被虚拟机加载的类信息、静态变量、常量、及时编译器编译后的代码
>

* 有什么特点？

>
* 线程共享
* 方法区逻辑上是堆中的老年代，里面保存的信息长期存在
* 内存回收效率低（主要是常量池的回收和类类型的卸载）
>


**Heap**

* 是什么？

>
>JVM 管理的内存中最大的一块
>
>虚拟机启动时创建
>
>堆唯一目的是存放对象实例
>

* 有什么特点？

>
* 线程共享
* 虚拟机启动时创建
* 垃圾回收发生的主要场所
* 可以细分为：新生代、老年代
* 主流虚拟机都支持动态拓展（-Xmx、-Xms动态指定大小）
* 备注：-Xmx 最大堆大小、-Xms 初始化堆大小
>

**VM Stack**

* 是什么？

>
Java方法的内存模型：每个方法在执行时都会创建一个栈帧，一个栈帧包含这么信息：
局部变量表、存放变量（基本数据类型变量、引用变量）、操作数栈、动态链接、方法出口信息等
>

* 有什么特点？

>
>线程私有（与线程同生命周期）
>
>方法运行过程的局部变量表大小固定（局部变量表内存在方法编译期间分配）
>
>long、double占2个局部变量空间（slot），其余类型占1个
>
>发生在这个区域有两种特殊的异常：StackOverflowError（线程请求的栈深度超过虚拟机允许的栈深度）、OutOfMemoryError（线程请求的内存空间大小超过虚拟机栈最大的内存空间大小）
>

**Native Method Area**

* 是什么？

> 
> 
本地方法栈与虚拟机栈类似，它们的区别在于：虚拟机栈是为虚拟机执行Java字节码服务，而本地方法栈是为虚拟机使用的本地方法（Native）服务
>

* 有什么特点？

>
同虚拟机栈
>

**Program Counter Register**

* 是什么？

>
当前线程所执行的字节码的行号指示器。里面存放的是当前正在执行的字节码的地址。
>

* 有什么特点？

>
>如果虚拟机正在执行的是一个Java方法，程序计数器中记录的则是字节码的地址
>
>如果虚拟机执行的是一个Native方法，程序计数器记录的则是空
>
>程序计数器是Java虚拟机规范中唯一没有OutOfMemoryError的区域
>
>

#### GC(Garbage Collection)垃圾回收

#####为什么需要GC？

>Java堆和方法区在程序运行时才能确定哪些对象会被创建，这部分的内存回收和分配都是动态的，所以需要GC来进行有策略的管理
>

#####哪些对象需要被回收？

* 引用计数法

>介绍：为每个对象添加一个引用计数器，每当有一个地方引用了该对象，则计数器加1，每当一个地方的引用失效，则计数器减1。GC根据引用计数器为0时，回收分配给该对象的内存空间。
>
>问题：无法解决对象相互引用的问题
>

* 可达性分析算法

>
>介绍：通过一系列称为“GC ROOT”对象作为根节点，从根节点向下引用走过的路径称为引用链，引用链上的所有节点都是可达的，GC会对“GC ROOT”对象不可达的节点进行回收。
>
>哪些对象可以作为“GC ROOT”对象呢？
>
>* 虚拟机栈中的引用的对象
>* 方法区中类静态属性引用的对象
>* 方法区中常量池引用的对象
>* 本地方法栈中JNI引用的对象 
>


##### 何为引用（Reference）？

* 强引用（Strong Reference）

>
> Object object = new Object() 这种方法创建的对象，都是强引用。只要强引用还存在，GC就不会回收被引用的对象
>

* 软引用（Soft Reference）

>
>软引用用来描述一些还有但是非必需的对象。系统在将要发生内存溢出之前，将会把这些对象列入回收范围之内。反过来说，如果系统已经抛出内存溢出OutOfMemoryError异常，则说你所有软引用对象已经被回收。
>

* 弱引用 (Weak Reference)

>
>弱引用用来描述非必需对象。被弱引用关联的对象只能存活到下一次垃圾收集发生之前。当GC开始工作的时候，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。反过来说，GC的基本工作就是要定期回收弱引用关联的对象。
>

* 虚引用（Phantom Reference）

>
>一个对象是否有虚引用的存在，完全不会对其生产时间构成影响
>
>为对象设置虚引用关联的唯一目的就是能在这个对象被GC回收时收到一个通知
>
>

#####如何回收？（垃圾回收算法）

* 标记清除算法（Mark-Sweep）

>
>算法流程：首先对需要回收的对象进行标记（对象判断已经在上面提到过），在标记完成之后统一进行对象回收工作。
>
>
>
>缺点：标记和清除过程效率都不高；空间问题，标记清除之后会产生很大内存碎片
>  

* 复制算法(Copying)

>
>算法流程：它讲可用内存按容量划分为大小相等的两块。每次只使用其中一块。当一块使用完毕，就将所有还存活的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清除掉。
>
>优点：每次只需要对一半的内存进行回收、内存分配不需要考虑内存碎片的问题
>
>缺点：内存利用率低（一次只能使用一般的内存空间）
>


* 标记整理算法(Mark-Compact)

>
>标记过程同标记清楚算法，但后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象都向一端移动，然后直接清楚掉端边界以外的内存
>

* 分代收集算法

>
>根据对象存活周期将内存划分为新生代、老年代。
>
>在新生代中，使用复制算法。
>
>对老年代中选择标记清除、或者标记整理算法回收``
>
>


####垃圾收集器分类

* Serial收集器（新生代、单线程、复制算法）

> 新生代收集器
> 
> 单线程执行：在进行垃圾收集时，需要停掉所有的用户线程
> 
> Serial收集器是运行在Client模式下的虚拟机首选的新生代垃圾收集器
> 
> 使用复制算法进行垃圾的回收
> 
>  
 
* ParNew收集器（新生代、多线程、复制算法）

>
>ParNew收集器是Serial收集器多线程版本，特点同Serial
>
>ParNew是运行在Server模式下的虚拟机首选的新生代垃圾收集器
>

* Parallel Scavenge收集器（新生代、多线程、复制算法）

>
>目标是到达一个可控制的吞吐量
>
>三种可控的虚拟机参数：
>
>-XX:MaxGCPauseMillis	最大垃圾收集停顿时间
>
>-XX:GCTimeRatio		直接设置吞吐量大小
>
>-XX:+UseAdaptiveSizePolicy    GC 自适应调节策略
>


* Serial Old收集器(老年代、单线程、标记-整理算法)

* Parallel Old收集器（老年代、多线程、标记-整理算法）

* CMS(Concurrent Mark Sweep)收集器（标记-清除算法）

>
>目标是获得最短回收停顿时间
>
>分为四个过程：初始标记（单线程）、并发标记（多线程）、重新标记（单线程）、并发清除（多线程）
>
>初始标记过程：快速标记一下与GC ROOT能够直接关联的对象
>
>并发标记：标记GC ROOT间接可达的对象
>
>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象
>
>并发清除：清除未被标记的对象
>
>
>缺点：无法处理浮动垃圾、产生大量的内存碎片
>


* G1收集器
>
>比较前沿的垃圾收集技术
>
>分为四个过程：初始标记、并发标记、最终标记、筛选回收
>
>前三个过程与CMS类似
>
>筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划
>
>
>


####内存分配与回收策略规则

* 大多数情况下，对象在新生代Eden区中进行分配。当Eden区没有足够空间，虚拟机将发起一次Minor GC。
* 大对象直接进入老年代。大对象指的是那些需要大量连续内存空间的Java对象（长的字符串、数组）
* 长期存活的对象将进入老年代。虚拟机给每个对象定义一个对象年龄（Age）计数器。如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移送到Survivor区，并且对象年龄设为1.对象在Survivor区每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁，可以通过-XX：MaxTenuringThreshold设置）就将晋升到老年代。
* 动态对象年龄判定。并不是永远都要求对象年龄到MaxTenuringThreshold才能晋升老年代；如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代
* 空间分配担保。虚拟机在进行Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC是安全的；否则，虚拟机会检查HandlePromotionFailure设置值是否允许担保失败，如果允许，那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC

#### JVM类加载（Class Loading）机制

* 简述：

>虚拟机将描述类信息的Class文件加载到内存，并对数据进行校验、转换解析、初始化，最终形成可以被虚拟机直接使用的Java类型



* 类的生命周期：

>load(加载)->verification（验证）->preparation（准备）->resolution（解析）->initialization（初始化）->using（使用）->unloading（卸载）
>
>

* 加载

>1）通过一个类的全限定名来获取定义此类的二进制字节流
>
>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
>
>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
>

* 验证

>1）文件格式验证
>
>2）元数据验证
>
>3）字节码验证
>
>4）符号引用验证
>

* 准备

>准备阶段是正式为类变量分配内存并设置类变量初始化值得阶段，这些变量所使用的内存都将在方法区中进行分配。
>
>
>

* 解析

>解析阶段虚拟机将常量池内的符号引用替换为成直接引用。
>
>符号引用：用一组符号来描述引用的对象。
>
>直接引用：直接指向目标的指针。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同
>
>


* 初始化顺序

>
>父类静态代码区、父类静态成员
>
>子类静态代码区和子类静态成员
>
>父类非静态代码区和普通成员
>
>父类非静态代码区和普通成员
>
>父类构造函数
>
>子类非静态代码区和普通成员
>
>子类构造函数
>
>
>

* 类初始化的时机：

主动引用：

>
>1. 使用new 实例化对象、读取或设置一个类的静态字段、调用类的静态方法。如果类没有进行初始化，则需要先触发其初始化。
>
>2. 使用java.lang.reflect包的方法对类进行反射调用。如果类没有进行初始化，则需要先触发其初始化。
>
>3. 当初始化一个类的时候，如果发现其父类还没初始化，则将父类进行初始化
>
>4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
>