#### JVM内存分析

**分为哪些部分？**
>
* Method Area（线程共享）
* Heap（线程共享）
* VM Stack （线程私有）
* Native Method Stack（线程私有）
* Program Counter Register（线程私有）
>

**Method Area（现在叫Permanent 永久区）**

* 是什么？

>
> 保持已经被虚拟机加载的类信息（Class）、静态变量（static）、常量（final）、即时编译器（JIT）编译后的代码
>

* 有什么特点？

>
>* 线程共享
>* 方法区逻辑上是堆中的老年代，里面保存的信息长期存在
>* 内存回收效率低（主要是常量池的回收和类类型的卸载）
>


**Heap**

* 是什么？

>
> JVM 管理的内存中最大的一块
>
> 虚拟机启动时创建
>
> 堆唯一目的是存放对象实例
>

* 有什么特点？

>
>* 线程共享
>* 虚拟机启动时创建
>* 垃圾回收发生的主要场所
>* 可以细分为：新生代、老年代
>* 主流虚拟机都支持动态拓展（-Xmx、-Xms动态指定大小）
>* 备注：-Xmx 最大堆大小、-Xms 初始化堆大小
>
>


* 堆内存划分

>
>Eden区（新生代）
>
>Survivor区（2块）（新生代）
>
>Tenured区（老年代）
>
>

#### GC的执行机制
	GC的执行有两种类型：Scavenge GC 和Full GC
	
**Scavenge GC**

>	
>* 一般情况下，当新对象生成，并且在Eden区申请内存失败时，就会触发 > Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把存活的对
>象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对>
>年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区
>开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因
>而，一般在这里需要使用速度快，效率高的算法，使Eden区尽快腾出
>空闲出来。
>	

**Full GC**

>
* Full GC对整个堆进行整理，包括Young、Tenured和Perm。Full GC 因为是对整个堆进行回收，所以要比Scavenge GC慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC进行调节。有以下情况会导致Full GC:

		1. 老年代（Tenured）被写满
		2. 持久代（Perm）被写满
		3. System.gc()被显示调用
		4. 上一次GC之后Heap的各域分配策略动态变化

>


**VM Stack**

* 是什么？

>
Java方法的内存模型：每个方法在执行时都会创建一个栈帧，一个栈帧包含这么信息：
局部变量表、存放变量（基本数据类型变量、引用变量）、操作数栈、动态链接、方法出口信息等
>

* 有什么特点？

>
>线程私有（与线程同生命周期）
>
>方法运行过程的局部变量表大小固定（局部变量表内存在方法编译期间分配）
>
>long、double占2个局部变量空间（slot），其余类型占1个
>
>发生在这个区域有两种特殊的异常：StackOverflowError（线程请求的栈深度超过虚拟机允许的栈深度）、OutOfMemoryError（线程请求的内存空间大小超过虚拟机栈最大的内存空间大小）
>

**Native Method Area**

* 是什么？

> 
> 
本地方法栈与虚拟机栈类似，它们的区别在于：虚拟机栈是为虚拟机执行Java字节码服务，而本地方法栈是为虚拟机使用的本地方法（Native）服务
>

* 有什么特点？

>
同虚拟机栈
>

**Program Counter Register**

* 是什么？

>
当前线程所执行的字节码的行号指示器。里面存放的是当前正在执行的字节码的地址。
>

* 有什么特点？

>
>如果虚拟机正在执行的是一个Java方法，程序计数器中记录的则是字节码的地址
>
>如果虚拟机执行的是一个Native方法，程序计数器记录的则是空
>
>程序计数器是Java虚拟机规范中唯一没有OutOfMemoryError的区域
>
>


#### GC(Garbage Collection)垃圾回收

#####为什么需要GC？

>Java堆和方法区在程序运行时才能确定哪些对象会被创建，这部分的内存回收和分配都是动态的，所以需要GC来进行有策略的管理
>

#####哪些对象需要被回收？

* 引用计数法

>介绍：为每个对象添加一个引用计数器，每当有一个地方引用了该对象，则计数器加1，每当一个地方的引用失效，则计数器减1。GC根据引用计数器为0时，回收分配给该对象的内存空间。
>
>问题：无法解决对象相互引用的问题
>

* 可达性分析算法

>
>介绍：通过一系列称为“GC ROOT”对象作为根节点，从根节点向下引用走过的路径称为引用链，引用链上的所有节点都是可达的，GC会对“GC ROOT”对象不可达的节点进行回收。
>
>哪些对象可以作为“GC ROOT”对象呢？
>
>* 虚拟机栈中的引用的对象
>* 方法区中类静态属性引用的对象
>* 方法区中常量池引用的对象
>* 本地方法栈中JNI引用的对象 
>


##### 何为引用（Reference）？

* 强引用（Strong Reference）

>
> Object object = new Object() 这种方法创建的对象，都是强引用。只要强引用还存在，GC就不会回收被引用的对象
>

* 软引用（Soft Reference）

>
>软引用用来描述一些还有但是非必需的对象。系统在将要发生内存溢出之前，将会把这些对象列入回收范围之内。反过来说，如果系统已经抛出内存溢出OutOfMemoryError异常，则说你所有软引用对象已经被回收。
>

* 弱引用 (Weak Reference)

>
>弱引用用来描述非必需对象。被弱引用关联的对象只能存活到下一次垃圾收集发生之前。当GC开始工作的时候，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。反过来说，GC的基本工作就是要定期回收弱引用关联的对象。
>

* 虚引用（Phantom Reference）

>
>一个对象是否有虚引用的存在，完全不会对其生产时间构成影响
>
>为对象设置虚引用关联的唯一目的就是能在这个对象被GC回收时收到一个通知
>
>

#####如何回收？（垃圾回收算法）

* 标记清除算法（Mark-Sweep）

>
>算法流程：首先对需要回收的对象进行标记（对象判断已经在上面提到过），在标记完成之后统一进行对象回收工作。
>
>
>
>缺点：标记和清除过程效率都不高；空间问题，标记清除之后会产生很大内存碎片
>  

* 复制算法(Copying)

>
>算法流程：它讲可用内存按容量划分为大小相等的两块。每次只使用其中一块。当一块使用完毕，就将所有还存活的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清除掉。
>
>优点：每次只需要对一半的内存进行回收、内存分配不需要考虑内存碎片的问题
>
>缺点：内存利用率低（一次只能使用一般的内存空间）
>


* 标记整理算法(Mark-Compact)

>
>标记过程同标记清楚算法，但后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象都向一端移动，然后直接清楚掉端边界以外的内存
>

* 分代收集算法

>
>根据对象存活周期将内存划分为新生代、老年代。
>
>在新生代中，使用复制算法。
>
>对老年代中选择标记清除、或者标记整理算法回收``
>
>


####垃圾收集器分类

* Serial收集器（新生代、单线程、复制算法）

> 新生代收集器
> 
> 单线程执行：在进行垃圾收集时，需要停掉所有的用户线程
> 
> Serial收集器是运行在Client模式下的虚拟机首选的新生代垃圾收集器
> 
> 使用复制算法进行垃圾的回收
> 
>  
 
* ParNew收集器（新生代、多线程、复制算法）

>
>ParNew收集器是Serial收集器多线程版本，特点同Serial
>
>ParNew是运行在Server模式下的虚拟机首选的新生代垃圾收集器
>

* Parallel Scavenge收集器（新生代、多线程、复制算法）

>
>目标是到达一个可控制的吞吐量
>
>三种可控的虚拟机参数：
>
>-XX:MaxGCPauseMillis	最大垃圾收集停顿时间
>
>-XX:GCTimeRatio		直接设置吞吐量大小
>
>-XX:+UseAdaptiveSizePolicy    GC 自适应调节策略
>


* Serial Old收集器(老年代、单线程、标记-整理算法)

* Parallel Old收集器（老年代、多线程、标记-整理算法）

* CMS(Concurrent Mark Sweep)收集器（标记-清除算法）

>
>目标是获得最短回收停顿时间
>
>分为四个过程：初始标记（单线程）、并发标记（多线程）、重新标记（单线程）、并发清除（多线程）
>
>初始标记过程：快速标记一下与GC ROOT能够直接关联的对象
>
>并发标记：标记GC ROOT间接可达的对象
>
>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象
>
>并发清除：清除未被标记的对象
>
>
>缺点：无法处理浮动垃圾、产生大量的内存碎片
>


* G1收集器

>比较前沿的垃圾收集技术
>
>分为四个过程：初始标记、并发标记、最终标记、筛选回收
>
>前三个过程与CMS类似
>
>筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划
>
>
>



		
		
		
##### Java中的内存泄漏

1.以下程序为例：

```
	HashMap<Object,Object> map = new HashMap();
	
	for(int i=0;i<10;i++){
		Object o = new Object();
		map.put(o,1);
		o=null;
	}
	
	//对map进行操作
	
	//无关map的操作，之后map也不再被使用

```
在上述程序中循环体中的o即使被赋值为null，GC也不会对其进行垃圾回收，原因是map中还存在着对它的引用，但是当map操作完成之后，此时按理说循环中创建的一系列对象已经没有用了，然而却无法进行回收，原因是map没有被释放掉，所以才会造成内存泄漏，如果在对map的操作完成之后，对赋值map=null，这样GC就能够释放掉不用的对象。

2.各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。

3.监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。



####内存分配与回收策略规则

* 大多数情况下，对象在新生代Eden区中进行分配。当Eden区没有足够空间，虚拟机将发起一次Minor GC。

* 大对象直接进入老年代。大对象指的是那些需要大量连续内存空间的Java对象（长的字符串、数组）


* 长期存活的对象将进入老年代。虚拟机给每个对象定义一个对象年龄（Age）计数器。如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移送到Survivor区，并且对象年龄设为1.对象在Survivor区每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁，可以通过-XX：MaxTenuringThreshold设置）就将晋升到老年代。


* 动态对象年龄判定。并不是永远都要求对象年龄到MaxTenuringThreshold才能晋升老年代；如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代


* 空间分配担保。虚拟机在进行Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC是安全的；否则，虚拟机会检查HandlePromotionFailure设置值是否允许担保失败，如果允许，那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC

#### JVM类加载（Class Loading）机制

* 简述：

>虚拟机将描述类信息的Class文件加载到内存，并对数据进行校验、转换解析、初始化，最终形成可以被虚拟机直接使用的Java类型



* 类的生命周期：

>load(加载)->verification（验证）->preparation（准备）->resolution（解析）->initialization（初始化）->using（使用）->unloading（卸载）
>
>

* 加载

>1）通过一个类的全限定名来获取定义此类的二进制字节流
>
>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
>
>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
>

* 验证

>1）文件格式验证
>
>2）元数据验证
>
>3）字节码验证
>
>4）符号引用验证
>

* 准备

>准备阶段是正式为类变量分配内存并设置类变量初始化值得阶段，这些变量所使用的内存都将在方法区中进行分配。
>
>
>

* 解析

>解析阶段虚拟机将常量池内的符号引用替换为成直接引用。
>
>符号引用：用一组符号来描述引用的对象。
>
>直接引用：直接指向目标的指针。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同
>
>


* 初始化顺序

>
>父类静态代码区、父类静态成员
>
>子类静态代码区和子类静态成员
>
>父类非静态代码区和普通成员
>
>父类非静态代码区和普通成员
>
>父类构造函数
>
>子类非静态代码区和普通成员
>
>子类构造函数
>
>
>

* 类初始化的时机：

主动引用：

>
>1. 使用new 实例化对象、读取或设置一个类的静态字段、调用类的静态方法。如果类没有进行初始化，则需要先触发其初始化。
>
>2. 使用java.lang.reflect包的方法对类进行反射调用。如果类没有进行初始化，则需要先触发其初始化。
>
>3. 当初始化一个类的时候，如果发现其父类还没初始化，则将父类进行初始化
>
>4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
>